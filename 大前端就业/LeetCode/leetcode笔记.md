### 1. 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。


**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**
```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**
```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**


* 2 <= nums.length <= 104
* -109 <= nums[i] <= 109
* -109 <= target <= 109
* 只会存在一个有效答案

**进阶**：你可以想出一个时间复杂度小于 O(n2) 的算法吗？

**题解**
```JavaScript
var twoSum = function(nums, target) {
    let map = new Map();
    for(let i = 0, len = nums.length; i < len; i++){
        // 1. 算出目标数字和当前数字的差
        // 2. 检查哈希表中是否存在该差，存在则返回结果
        if(map.has(target - nums[i])){ 
            return [map.get(target - nums[i]), i];
        // 3. 不存在，当前数字作为key，索引作为value存入哈希表
        }else{
            map.set(nums[i], i);
        }
    }
    return [];
};
```
```
执行用时：60 ms
内存消耗：42.2 MB
```
***

### 2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

输入：

> (2) ----> (4) ----> (3)

> (5) ----> (6) ----> (4)

结果：
> (7) ----> (0) ----> (8)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**
```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**
```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**

* 每个链表中的节点数在范围 [1, 100] 内
* 0 <= Node.val <= 9
* 题目数据保证列表表示的数字不含前导零

方法一：模拟
思路与算法

由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。

我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 **n1, n2**进位值为**carry**，则它们的和为 **n1 + n2 + carry**；其中，答案链表处相应位置的数字为 **(n1 + n2 + carry)mod10**，而新的进位值为  ⌊ 
$$h_w(x)=\frac{n1 + n2 + carry}{10}$$ 
⌋。

如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0。

此外，如果链表遍历结束后，有 **carry > 0**，还需要在答案链表的后面附加一个节点，节点的值为 **carry。**

**题解**

```JavaScript
var addTwoNumbers = function(l1, l2) {
    // 链表头 和 当前链表的位置
    let head = null, tail = null;
    // 进位
    let carry = 0;
    // 同时遍历两个链表l1 l2
    while (l1 || l2) {
        // 获取链表当前位置的值（指针）
        // 如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0。
        const n1 = l1 ? l1.val : 0;
        const n2 = l2 ? l2.val : 0;
        // 计算当前位置的和
        const sum = n1 + n2 + carry;
        // 链表头为空， 则当前链表位置赋值，赋sum % 10 的余数
        if (!head) {
            head = tail = new ListNode(sum % 10);
        // 链表头不为空，链表下一个指针位置赋值，赋sum % 10 的余数
        } else {
            tail.next = new ListNode(sum % 10);
            // 链表当前位置tail，往后加一位（指针++）
            tail = tail.next;
        }
        // 计算进位（满十进一）
        carry = Math.floor(sum / 10);
        // 更新两个链表l1 和 l2位置(指针++)
        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
    }
    // 最后一定记得，有进位的话，需要链表多出来一位存进位carry的值
    // 存在进位 则链表下一项进一位
    if (carry > 0) {
        tail.next = new ListNode(carry);
    }
    // 最后返回求和链表结果head
    return head;
};
```
```
执行用时：100 ms
内存消耗：46.7 MB
```

***

### 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

* 0 <= s.length <= 5 * 104
* s 由英文字母、数字、符号和空格组成


方法一：滑动窗口
思路和算法

我们先用一个例子考虑如何在较优的时间复杂度内通过本题。

我们不妨以示例一中的字符串 **abcabcbb** 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：

* 以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；
* 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；
* 以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；
* 以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb；
* 以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；
* 以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；
* 以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；
* 以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。

发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。

这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

* 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk；

* 在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

* 在枚举结束后，我们找到的最长的子串的长度即为答案。

**判断重复字符**

在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。

至此，我们就完美解决了本题。

**复杂度分析**

时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。

空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即 ∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。

**题解**
```JavaScript
var lengthOfLongestSubstring = function(s) {
    // 哈希集合，记录每个字符是否出现过
    const occ = new Set();
    const n = s.length;
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    let rk = -1, ans = 0;
    for (let i = 0; i < n; ++i) {
        if (i != 0) {
            // 左指针向右移动一格，移除一个字符
            occ.delete(s.charAt(i - 1));
        }
        while (rk + 1 < n && !occ.has(s.charAt(rk + 1))) {
            // 不断地移动右指针
            occ.add(s.charAt(rk + 1));
            ++rk;
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = Math.max(ans, rk - i + 1);
    }
    return ans;
};
```

```
执行用时：76 ms
内存消耗：45.6 MB
```