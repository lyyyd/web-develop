### 1. 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。


**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**
```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**
```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**


* 2 <= nums.length <= 104
* -109 <= nums[i] <= 109
* -109 <= target <= 109
* 只会存在一个有效答案

**进阶**：你可以想出一个时间复杂度小于 O(n2) 的算法吗？

**题解**
```JavaScript
var twoSum = function(nums, target) {
    let map = new Map();
    for(let i = 0, len = nums.length; i < len; i++){
        // 1. 算出目标数字和当前数字的差
        // 2. 检查哈希表中是否存在该差，存在则返回结果
        if(map.has(target - nums[i])){ 
            return [map.get(target - nums[i]), i];
        // 3. 不存在，当前数字作为key，索引作为value存入哈希表
        }else{
            map.set(nums[i], i);
        }
    }
    return [];
};
```
```
执行用时：60 ms
内存消耗：42.2 MB
```
***

### 2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

输入：

> (2) ----> (4) ----> (3)

> (5) ----> (6) ----> (4)

结果：
> (7) ----> (0) ----> (8)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**
```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**
```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**

* 每个链表中的节点数在范围 [1, 100] 内
* 0 <= Node.val <= 9
* 题目数据保证列表表示的数字不含前导零

方法一：模拟
思路与算法

由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。

我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 **n1, n2**进位值为**carry**，则它们的和为 **n1 + n2 + carry**；其中，答案链表处相应位置的数字为 **(n1 + n2 + carry)mod10**，而新的进位值为  ⌊ 
$$h_w(x)=\frac{n1 + n2 + carry}{10}$$ 
⌋。

如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0。

此外，如果链表遍历结束后，有 **carry > 0**，还需要在答案链表的后面附加一个节点，节点的值为 **carry。**

代码

```JavaScript
var addTwoNumbers = function(l1, l2) {
    // 链表头 和 当前链表的位置
    let head = null, tail = null;
    // 进位
    let carry = 0;
    // 同时遍历两个链表l1 l2
    while (l1 || l2) {
        // 获取链表当前位置的值（指针）
        // 如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0。
        const n1 = l1 ? l1.val : 0;
        const n2 = l2 ? l2.val : 0;
        // 计算当前位置的和
        const sum = n1 + n2 + carry;
        // 链表头为空， 则当前链表位置赋值，赋sum % 10 的余数
        if (!head) {
            head = tail = new ListNode(sum % 10);
        // 链表头不为空，链表下一个指针位置赋值，赋sum % 10 的余数
        } else {
            tail.next = new ListNode(sum % 10);
            // 链表当前位置tail，往后加一位（指针++）
            tail = tail.next;
        }
        // 计算进位（满十进一）
        carry = Math.floor(sum / 10);
        // 更新两个链表l1 和 l2位置(指针++)
        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
    }
    // 最后一定记得，有进位的话，需要链表多出来一位存进位carry的值
    // 存在进位 则链表下一项进一位
    if (carry > 0) {
        tail.next = new ListNode(carry);
    }
    // 最后返回求和链表结果head
    return head;
};
```
```
执行用时：100 ms
内存消耗：46.7 MB
```

***